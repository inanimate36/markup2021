knitr::opts_chunk$set(echo = FALSE)
library(shiny)
library(ggplot2)
library(dplyr)
library(psych)
inputPanel(
selectInput("n_breaks", label = "Number of bins:",
choices = c(10, 20, 35, 50), selected = 20),
sliderInput("bw_adjust", label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
)
renderPlot({
hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
xlab = "Duration (minutes)", main = "Geyser eruption duration")
dens <- density(faithful$eruptions, adjust = input$bw_adjust)
lines(dens, col = "blue")
})
knitr::opts_chunk$set(echo = FALSE)
library(shiny)
summary(cars)
library(titanic)
install.packages("titanic")
library(titanic)
dat <- titanic
?datatable
??datatable
??DT
datatable(USArrests, options = list(pageLength = 6))
install.packages("DT")
?datatable
datatable(USArrests, options = list(pageLength = 6))
require(igraph)
library(igraphdata)
data("enron")
datatable(USArrests, options = list(pageLength = 6))
data("enron")
enron
#############
# ein subgraph, bei der nur die emails mit thema drin sind (alle über 0)
enron2 <- subgraph.edges(enron, which(E(enron)$LDC_topic > 0))
# simplify aber ohne die multiples zu removen
enron3 <- simplify(enron2, remove.multiple = FALSE, remove.loops = TRUE)
# die nodes, die keinen kontakt haben, werden nicht mitanalyisiert
enron4 <- enron3 - vertices(c("71","87", "117", "149"))
# Variable, bei der für jeden Knoten die Anzahl an verschiedenen Themen steht
received <- sapply(1:vcount(enron4), function(i) {
length(table(E(enron4)[to (i)]$LDC_topic))})
received
mean(received)
median(received)
hist(received, main=NA,
xlab="Menge erhaltener Themen",ylab="Personen",
breaks = 30,
col = "green", xlim = c(0, 29), ylim = c(0, 15))
# min(received)
shapiro.test(received) # no normal distribution
#Als Knotenattribut
V(enron4)$received <- received
##############
# durch die Knotenattribute werden doppelte Kanten nicht mehr gebraucht
enron5 <- simplify(enron4)
##############
# constraint-maß als variable
const <- constraint(enron5)
mean(const)
median(const)
hist(const, main = NA,
xlab="Constraint-Maß",ylab="Personen",
xlim=c(0.0,0.58), ylim = c(0, 70),
col = "blue")
max(const)
boxplot(const) # Maxwert ist Ausreißer
shapiro.test(const) # no normal distribution
V(enron5)$const <- constraint(enron5)
##############
quantile(const)
V(enron5)[const <  "0.08591"]$color <- "green"
V(enron5)[const >  "0.08591"]$color <- "red"
plot(enron5, vertex.size=(V(enron5)$received)*0.5^2, edge.arrow.size=0,
edge.width = 0.4, edge.color = "blue", vertex.label = NA, layout = layout_with_fr)
require(igraph)
library(igraphdata)
data("enron")
# ein subgraph, bei der nur die emails mit thema drin sind (alle über 0)
enron2 <- subgraph.edges(enron, which(E(enron)$LDC_topic > 0))
# simplify aber ohne die multiples zu removen
enron3 <- simplify(enron2, remove.multiple = FALSE, remove.loops = TRUE)
# die nodes, die keinen kontakt haben, werden nicht mitanalyisiert
enron4 <- enron3 - vertices(c("71","87", "117", "149"))
received <- sapply(1:vcount(enron4), function(i) {
length(table(E(enron4)[to (i)]$LDC_topic))})
received
#Als Knotenattribut
V(enron4)$received <- received
##############
##############
# durch die Knotenattribute werden doppelte Kanten nicht mehr gebraucht
enron5 <- simplify(enron4)
##############
# constraint-maß als variable
const <- constraint(enron5)
V(enron5)$const <- constraint(enron5)
V(enron5)[const <  "0.08591"]$color <- "green"
V(enron5)[const >  "0.08591"]$color <- "red"
plot(enron5, vertex.size=(V(enron5)$received)*0.5^2, edge.arrow.size=0,
edge.width = 0.4, edge.color = "blue", vertex.label = NA, layout = layout_with_fr)
legend("bottomright", legend=c("Untersten 25%","Restlichen 75%"), col=c("green", "red"), pch=19, pt.cex=3,cex=0.6,ncol = 2, title = "Constraint-Wert")
install.packages("plotly")
require(igraph)
library(igraphdata)
data("enron")
# ein subgraph, bei der nur die emails mit thema drin sind (alle über 0)
enron2 <- subgraph.edges(enron, which(E(enron)$LDC_topic > 0))
# simplify aber ohne die multiples zu removen
enron3 <- simplify(enron2, remove.multiple = FALSE, remove.loops = TRUE)
# die nodes, die keinen kontakt haben, werden nicht mitanalyisiert
enron4 <- enron3 - vertices(c("71","87", "117", "149"))
received <- sapply(1:vcount(enron4), function(i) {
length(table(E(enron4)[to (i)]$LDC_topic))})
received
#Als Knotenattribut
V(enron4)$received <- received
##############
##############
# durch die Knotenattribute werden doppelte Kanten nicht mehr gebraucht
enron5 <- simplify(enron4)
##############
# constraint-maß als variable
const <- constraint(enron5)
V(enron5)$const <- constraint(enron5)
V(enron5)[const <  "0.08591"]$color <- "green"
V(enron5)[const >  "0.08591"]$color <- "red"
plot(enron5, vertex.size=(V(enron5)$received)*0.5^2, edge.arrow.size=0,
edge.width = 0.4, edge.color = "blue", vertex.label = NA, layout = layout_with_fr)
legend("bottomright", legend=c("Untersten 25%","Restlichen 75%"), col=c("green", "red"), pch=19, pt.cex=3,cex=0.6,ncol = 2, title = "Constraint-Wert")
require(plotly)
require(igraph)
library(igraphdata)
data("enron")
# ein subgraph, bei der nur die emails mit thema drin sind (alle über 0)
enron2 <- subgraph.edges(enron, which(E(enron)$LDC_topic > 0))
# simplify aber ohne die multiples zu removen
enron3 <- simplify(enron2, remove.multiple = FALSE, remove.loops = TRUE)
# die nodes, die keinen kontakt haben, werden nicht mitanalyisiert
enron4 <- enron3 - vertices(c("71","87", "117", "149"))
received <- sapply(1:vcount(enron4), function(i) {
length(table(E(enron4)[to (i)]$LDC_topic))})
received
#Als Knotenattribut
V(enron4)$received <- received
##############
##############
# durch die Knotenattribute werden doppelte Kanten nicht mehr gebraucht
enron5 <- simplify(enron4)
##############
# constraint-maß als variable
const <- constraint(enron5)
V(enron5)$const <- constraint(enron5)
V(enron5)[const <  "0.08591"]$color <- "green"
V(enron5)[const >  "0.08591"]$color <- "red"
p <- plot(enron5, vertex.size=(V(enron5)$received)*0.5^2, edge.arrow.size=0,
edge.width = 0.4, edge.color = "blue", vertex.label = NA, layout = layout_with_fr)
legend("bottomright", legend=c("Untersten 25%","Restlichen 75%"), col=c("green", "red"), pch=19, pt.cex=3,cex=0.6,ncol = 2, title = "Constraint-Wert")
ggplotly(p)
USArrests
require(plotly)
dat <- USArrests
p <- ggplot(dat, aes(x = Murder, y = UrbanPop)) +
geom_point() +
ggtitle("Murder vs. Urban Population")
ggplotly(p)
p <- plot(enron5, vertex.size=(V(enron5)$received)*0.5^2, edge.arrow.size=0,
edge.width = 0.4, edge.color = "blue", vertex.label = NA, layout = layout_with_fr)
require(plotly)
require(igraph)
library(igraphdata)
data("enron")
# ein subgraph, bei der nur die emails mit thema drin sind (alle über 0)
enron2 <- subgraph.edges(enron, which(E(enron)$LDC_topic > 0))
# simplify aber ohne die multiples zu removen
enron3 <- simplify(enron2, remove.multiple = FALSE, remove.loops = TRUE)
# die nodes, die keinen kontakt haben, werden nicht mitanalyisiert
enron4 <- enron3 - vertices(c("71","87", "117", "149"))
received <- sapply(1:vcount(enron4), function(i) {
length(table(E(enron4)[to (i)]$LDC_topic))})
received
#Als Knotenattribut
V(enron4)$received <- received
##############
##############
# durch die Knotenattribute werden doppelte Kanten nicht mehr gebraucht
enron5 <- simplify(enron4)
##############
# constraint-maß als variable
const <- constraint(enron5)
V(enron5)$const <- constraint(enron5)
V(enron5)[const <  "0.08591"]$color <- "green"
V(enron5)[const >  "0.08591"]$color <- "red"
p <- plot(enron5, vertex.size=(V(enron5)$received)*0.5^2, edge.arrow.size=0,
edge.width = 0.4, edge.color = "blue", vertex.label = NA, layout = layout_with_fr)
ggplotly(p)
